<template>
    <div class="input-group">
        <div ref="tokenSearch" @keyup.enter="onItemSelected">
            <autocomplete
                    ref="searchInput"
                    :value="searchValue"
                    :input-class="inputClass"
                    placeholder="Search for the token"
                    :auto-select-one-item="false"
                    @update-items="searchUpdate"
                    @item-clicked="onItemSelected"
                    @change="onInputChange"
                    :items="items"
                    :min-len="3"
                    :input-attrs="inputAttrs"
            >
            </autocomplete>
        </div>
        <div class="input-group-append position-relative ml-2">
            <div v-if="input" class="clear-search-icon">
                <font-awesome-icon size="xs" @click="clearSearch" class="c-pointer" icon="times"></font-awesome-icon>
            </div>
            <span class="input-group-text text-white">
                <font-awesome-icon class="c-pointer" @click="redirectToToken" icon="search"></font-awesome-icon>
            </span>
        </div>
    </div>
</template>

<script>
import Autocomplete from 'v-autocomplete';
import {LoggerMixin, NotificationMixin} from '../../mixins';

const tokenRegEx = new RegExp('^[a-zA-Z0-9\\-\\s]*$');

export default {
    name: 'TokenSearcher',
    mixins: [NotificationMixin, LoggerMixin],
    components: {
        Autocomplete,
    },
    props: {
        searchUrl: {type: String, required: true},
    },
    data() {
        return {
            validName: true,
            input: '',
            searchValue: undefined,
            items: [],
            inputAttrs: {
                maxlength: 60,
            },
        };
    },
    methods: {
        searchUpdate: function(value) {
            this.$axios.retry.get(
                this.searchUrl,
                {params: {tokenName: value}}
            ).then((response) => {
                this.items = response.data.map((token) => {
                    return token.name;
                });
            }).catch((error) => {
                this.notifyError('Service timeout');
                this.sendLogs('error', 'Service timeout error', error);
            });
        },
        redirectToToken: function() {
            if (!tokenRegEx.test(this.input)) {
                return;
            }
            if (this.input.trim().length === 0) {
                location.href = this.$routing.generate('trading');
                return;
            }
            location.href = this.$routing.generate('token_show', {name: this.input}, true);
        },
        onItemSelected: function(val) {
            this.input = val.isTrusted ? val.target.value : val;
            this.redirectToToken();
        },
        onInputChange: function(val) {
            this.validName = tokenRegEx.test(val);
            this.input = val;
            this.items = [];
        },
        clearSearch: function() {
            this.input = '';
            this.searchValue = '';
            this.items = [];
            this.$nextTick(() => {
                this.searchValue = undefined;
            });
        },
    },
    computed: {
        inputClass: function() {
            return 'search-input px-3 no-bg-img ' + (this.validName ? '' : 'is-invalid');
        },
    },
};
</script>
